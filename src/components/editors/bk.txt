import { Stage, Text } from '@pixi/react';
import { CSS_VARIABLES, RESOURCE_FOLDERS } from '_constants';
import EditorCanvas from 'elements/EditorCanvas';
import { ResourcePack } from 'models/ResourcePack';
import React, { useEffect, useMemo, useRef, useState } from 'react';
import { Vec2, getClassString, getCssVariableValue } from 'utils';

export interface _LevelEditor_Content_CanvasProps {
    viewBox: DOMRect;
    pack: ResourcePack;
    width: number;
    height: number;
    background: string | null | undefined;
    className?: string;
}

function _LevelEditor_Content_Canvas ({
    viewBox,
    pack,
    width,
    height,
    background,
    className,
}: _LevelEditor_Content_CanvasProps) {
    const [btnDown, setBtnDown] = useState<'left' | 'right' | null>(null);
    const [_temp, _setTemp] = useState<Vec2[]>([]);
    const [_tempTile, _setTempTile] = useState<HTMLImageElement | null>(null);

    useEffect(() => {
        load();

        async function load () {
            const tilePath = pack.fullPath + "\\" + RESOURCE_FOLDERS.sprites.tiles + "\\ground_wooden.png";
            const img = await loadImage(tilePath);
            _setTempTile(img);
            console.log("rel");
        }
    }, [])

    const canvasRef = useRef<HTMLCanvasElement | null>(null);
    const ctxRef = useRef<CanvasRenderingContext2D | null>(null);

    const bgColor = getCssVariableValue(CSS_VARIABLES.ComponentColorTheme0);

    useEffect(() => {
        document.addEventListener('mouseup', handleMouseUp);

        const canvas = canvasRef.current;
        if (canvas === null) {
            return;
        }
        
        const ctx = canvas.getContext('2d');
        ctxRef.current = ctx;

        if (ctx === null) return;
        
        ctx.lineCap = "round";
        ctx.strokeStyle = "black";
        ctx.lineWidth = 5;
        
        //ctx.fillStyle = bgColor;
        //ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        ctx.beginPath();
        ctx.moveTo(666, 333);
        ctx.lineTo(100, 100);
        ctx.stroke();

        return () => {
            document.removeEventListener('mouseup', handleMouseUp);
        };
    }, []);

    useEffect(() => {
        const ctx = ctxRef.current;
        if (ctx === null) return;

        //ctx.font = "50px arial";
        //ctx.fillText(`${viewBox.x}, ${viewBox.y}`, 5, 5);
        //ctx.beginPath();
        //ctx.moveTo(100, 100);
        //ctx.lineTo(355, Math.random());
        //ctx.stroke();
        //console.log("a");

        drawLevel();
    }, [viewBox]);

    const classStr = getClassString(
        "level-grid-canvas",
        className,
    );

    return (
        <canvas
            ref={canvasRef}
            className={classStr}
            width={width * 16}
            height={height * 16}
            onMouseDown={handleMouseDown}
            onMouseMove={handleMouseMove}
        />
    );

    function handleMouseDown (evt: React.MouseEvent<HTMLCanvasElement, MouseEvent>) {
        if (evt.buttons === 1) {
            setBtnDown('left');
        }
        else if (evt.buttons === 2) {
            setBtnDown('right');
        }
    }

    function handleMouseMove (evt: React.MouseEvent<HTMLCanvasElement, MouseEvent>) {
        if (btnDown === 'left') {
            const rect = canvasRef.current?.getBoundingClientRect();
            if (!rect) return;

            const pos = {
                x: evt.clientX - rect.left,
                y: evt.clientY - rect.top,
            }
            
            const tilePos = {x: Math.floor(pos.x / 16), y: Math.floor(pos.y / 16)};

            if (_temp.find(p => p.x === tilePos.x && p.y === tilePos.y)) return;
            _setTemp(prevState => [
                ...prevState,
                tilePos,
            ]);

            const ctx = ctxRef.current;
            if (ctx === null || _tempTile === null) return;

            ctx.clearRect(0, 0, canvasRef.current!.width, canvasRef.current!.height);
            for (const pos of [..._temp, tilePos]) {
                ctx.drawImage(_tempTile, pos.x * 16, pos.y * 16);
            }
        }
    }

    function handleMouseUp (evt: MouseEvent) {
        setBtnDown(null);
    }

    async function drawLevel () {
        const ctx = ctxRef.current;
        if (ctx === null) return;


    }
}

function loadImage (path: string) : Promise<HTMLImageElement> {
    return new Promise((resolve, reject) => {
        const image = new Image();
        image.addEventListener('load', () => resolve(image));
        image.src = "asset://" + path;
    });
}

export default _LevelEditor_Content_Canvas;
